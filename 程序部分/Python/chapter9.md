# chapter9

## 字符串的驻留机制

* 字符串
  再Python中字符串是基本数据类型，是一个不可变的字符序列

* 什么叫字符串驻留机制呢？
  仅保存一份相同且不可变字符串的方法，不同的值呗存放在字符串的驻留池中，Python的驻留机制对相同的字符串只保存一份拷贝，后续创建相同字符串时，不会开辟新空间，而是把该字符串的地址赋给新创建的变量

```python
# 字符串的驻留机制
a = 'Python'
b = "Python"
c = '''Python'''
print(id(a))
print(id(b))
print(id(c))# 观察输出可以知道，这三个字符串都是同一个内存地址（同一个对象）
```

* 驻留机制的几种情况（交互模式：cmd+python）
  * 字符串长度为0或1时
  * 符合标识符的字符串（数字，字母，下划线）
  * 字符串只在编译时进行驻留，而非运行时
  * [-5，256]之间的整数数字

```python
>>> s1 = ''
>>> s2 = ''
>>> s1 == s2
True
>>> s1 is s2
True
>>> s1 = 'abc('
>>> s2 = 'abc('
>>> s1 is s2
False
```

* sys中的intern方法强制2个字符串指向同一个对象

```python
>>> import sys
>>> a = 'abc('
>>> b = 'abc('
>>> a is b
False
>>> a = sys.intern(b)
>>> a is b
True
```

* PyCharm对字符串进行了优化处理
* 字符串驻留机制的优缺点
  * 当需要值相同的字符串时，可以直接从字符串池子里拿来使用，避免频繁的创建和销毁，提高效率和节约内存，因此拼接字符串和修改字符串时会比较影响性能的
  * 再需要进行字符串拼接时，建议使用str类型的join方法，而非+，因为join（）方法时先计算出所有字符串中的长度，然后再拷贝，只呢new一次对象，效果比“+”效率高



## 字符串的常用操作

* 查找操作

| 方法名称   | 作用                                                         |
| ---------- | ------------------------------------------------------------ |
| index（）  | 查找子串substr第一次出现的位置，如果查找的子串不存在时，则抛出ValueError |
| rindex（） | 查找子串substr最后一次出现的位置，如果查找的子串不存在时，则抛出ValueError |
| find（）   | 查找子串substr第一次出现的位置，如果查找的子串不存在时，则返回-1 |
| rfind（）  | 查找子串substr最后一次出现的位置，如果查找的子串不存在时，则返回-1 |

* 字符串的大小写转换操作的方法

| 方法名称       | 作用                                                         |
| -------------- | ------------------------------------------------------------ |
| upper（）      | 把字符串中所有字符都转成大写字母                             |
| lower（）      | 把字符串中所有的字符都转成小写字母                           |
| swapcase（）   | 把字符串中所有大写字母都转成小写字母，把所有小写字母都转成大写字母 |
| capitalize（） | 把第一个字符转换为大写，把其余字符都转换为小写               |
| title（）      | 把每个单词的第一个字符转换为大写，把每个单词的剩余字符转换为小写 |

```python
# 字符串的大小写转换操作的方法
str1 = 'Hello Bangdi'
print(str1.upper())
print(str1.lower())
print(str1.swapcase())
print(str1.capitalize())
print(str1.title())
```

* 字符串内容对齐操作的方法

| 方法名称   | 作用                                                         |
| ---------- | ------------------------------------------------------------ |
| center（） | 居中对齐，第1个参数指定填充符，第2个参数是可选的，默认是空格，如果设置宽度小于实际宽度则返回原字符串 |
| ljust（）  | 左对齐，第1个参数指定宽度，第2个参数指定填充符，第2个参数是可选的，默认是空格，如果设置宽度小于实际宽度则会返回原字符串 |
| rjust（）  | 右对齐，第1个参数指定宽度，第2个参数指定填充符，第2个参数是可选的，默认是空格，如果设置宽度小于实际宽度则会返回原字符串 |
| zfill（）  | 右对齐，左边用0填充，该方法只接受一个参数，用于指定字符串的宽度，如果指定的宽度小于等于字符串的长度，返回字符串本身 |

```python
# 字符串内容对齐操作的方法
str1 = 'Hello Python'
'''center 居中对齐'''
print(str1.center(16, '*'))  # 前一个参数指定宽度，后一个参数指定填充的字符
print(str1.center(16))  # 无参情况下是空格
print(str1.center(12, '0'))  # 如果宽度小于初始字符串长度则返回原字符串

'''ljust 左对齐'''
print(str1.ljust(16, '*'))

'''rjust 右对齐'''
print(str1.rjust(16, '*'))

'''右对齐，左边用0填充'''
print(str1.zfill(16))
```



## 字符串劈分操作的方法

| 方法名称   | 作用                                                         |
| ---------- | ------------------------------------------------------------ |
| split（）  | 从字符串的左边开始劈分，默认的劈分字符是空格字符串，返回的值都是一个列表<br />以通过参数sep指定劈分字符串时的劈分符<br />通过参数maxsplit指定劈分字符串时的最大劈分次数，在经过最大次数劈分之后，剩余的子串会单独做为一部分 |
| rsplit（） | 从字符串的右边开始劈分，默认的劈分字符时空格字符串，返回的值都是一个列表<br />以通过参数sep指定劈分字符串时的劈分字符<br />通过参数maxsplit指定劈分字符串时的最大劈分次数，在经历最大次数劈分之后，剩余的子串会单独作为一部分 |

```python
# 字符串劈分操作的方法
str1 = 'Hello Python Hello Bangdi'
print(str1.split())  # 无参情况下会按照空格分割，返回值是一个列表
str1 = 'Hello|Python|Hello|Bangdi'
print(str1.split('|', 1))  # 第一个参数指定按什么字符串进行分割，第二个参数指定分割几次
print(str1.rsplit('|'))  # 从左分割，从右分割再无参情况下效果一致
print(str1.rsplit('|', 1))  # 区别在于如果指定分割次数时，开始分割的方向不同
```



## 判断字符串的操作方法

| 方法名称         | 作用                                                         |
| ---------------- | ------------------------------------------------------------ |
| isidentifier（） | 判断指定的字符串是不是合法的标识符                           |
| isspace（）      | 判断指定的字符串是否全部由空白字符串组成（回车，换行，水平制表符） |
| isalpha（）      | 判断指定的字符串是否全部由字母组成                           |
| isdecimal（）    | 判断指定字符串是否全部由十进制的数字组成                     |
| isnumeric（）    | 判断指定的字符串是否全部由数字组成                           |
| isalnum（）      | 判断指定字符串是否由字母和数字组成                           |

```python
# 判断字符串的操作
str1 = '1bangdi'
'''判断字符串是否为合法标识符'''
print(str1.isidentifier())
str2 = '_bangdi'
print(str2.isidentifier())
'''判断指定的字符串是否全部由空白字符串组成(空格，回车，换行，水平制表符)'''
str3 = '    \r '
print(str3.isspace())
'''判断指定的字符串是否全部由字母组成'''
str4 = 'bangdi'
print(str4.isalpha())
str4 = 'bang di'
print(str4.isalpha())
'''判断指定的字符串是否全部由十进制数字组成'''
str5 = '123四56'
print(str5.isdecimal())
'''判断指定的字符串是否全部由数字组成（汉字四也算）'''
str6 = '010四'
print(str6.isnumeric())
'''判断字符串是否由字母和数字构成'''
str7 = 'bangdi7'
print(str7.isalnum())
```



## 字符串的其他操作

| 方法名称    | 作用                                                         |
| ----------- | ------------------------------------------------------------ |
| replace（） | 第一个参数指定被替换的子串，第二个参数指定替换子串的字符串，该方法返回替换后得到的字符串，替换前的字符串不发生变化，调用该方法时可以通过第3个参数指定最大替换次数 |
| join（）    | 将列表或元组的字符串合并成一个字符串                         |

```python
# 字符串操作的其他方法
str1 = 'Hello bangdi Hello Python'
str2 = str1.replace('l', '*')
print(str2)
str3 = str1.replace('l', '*', 2)  # 目标字符串，替换后的字符串，替换次数
print(str3)
print(str1)

lst1 = ['bang', 'di', 123]
print(''.join(lst1))  # 将列表或元组的字符串合并成一个字符串
```



## 字符串的比较操作

* 运算符：>,>=,<,<=,==,!=
* 比较规则：首先比较两个字符串中的第一个字符，如果相等则继续比较下一个字符，依次比较下去，知道两个字符串中的字符不相等时，其比较结果就是两个字符串的比较结果，两个字符串中所有后续字符将不再被比较
* 比较原理：两个字符串进行比较时，比较的是其ordinal value（原始值），调用内置函数ord可以得到指定字符的ordinal value，与内置函数ord对应的是内置函数chr，调用内置函数chr时指定ordinal value可以得到其对应的字符

```python
# 字符串的比较操作
print(ord('A'))
str1 = 'Hello Python'
str2 = 'Hello Python'
print(str1 == str2)
str1 = '杨'
str2 = '杨'
print(str1 == str2)
str1 = 'bangdi('
str2 = 'bangdi('
print(str1 == str2)
print(str1 is str2) # 这里正常因该是False，因为Pycharm的优化故变为True
```



## 字符串的切片操作(重点)

* 字符串时可不变类型
  * 不具备增，删，改等操作
  * 切片操作将产生新的对象

```python
# 字符串的切片操作
str1 = 'Hello Python'
str2 = str1[:5]
print(str2)
str3 = str1[5:]  # 左闭右开
print(str3)
str4 = str1[::2]  # 步长为2
print(str4)
str5 = str1[::-1]  # 步长为负数时字符串是倒过来的
print(str5)
str6 = str1[-1:-13:-1]  # 同样也是左闭右开
print(str6)
```



## 格式化字符串（重点）

* 为什么需要格式化字符串

  预留代码，完型填空

* 格式化字符串的两种方式
  * %作占位符
  * {}作占位符

```python
# 格式化字符串
# 格式化字符串的两种方式
name = 'bangdi'
age = 23
print('我的名字叫：%s,今年%d岁了' % (name, age))  # 第一种方式 %作占位符：%s要求传进来的是字符串，%d要求传进来的是数字
print('我的名字叫：{0},今年{1}岁了，我真的叫{0}'.format(name, age))  # 第二种方式 {}作占位符：只要求给出索引即可

print('%10d' % 99)  # 10表示的是宽度,不够的情况下前面会补上空格
print('%.3f' % 3.1415926)  # .3 表示的是小数点后三位
print('%10.3f' % 3.1415926)  # 宽度为10，小数点后三位
print('1234567890')
print('{0:.3}'.format(3.1415926))
print('{0:.3f}'.format(3.1415926)) # .3f表示的是3位小数
print('{0:10.3f}'.format(3.1415926)) # .3f表示的是3位小数
```



## 字符串的编码转换

* 为什么需要字符串的编码转换

计算机只认识0和1（方便传输）

* 编码与解码的方式
  * 编码：将字符串转换为二进制数据（bytes）
  * 解码：将bytes类型的数据转换成字符串类型

```python
# 字符串的编码与解码
str1 = '邦迪,bangdi'
print(str1.encode(encoding='GBK'))  # GBK编码中，一个中文占两个字节
print(str1.encode(encoding='UTF-8'))  # UTF-8这种编码格式中，一个中文占三个字符

byte = str1.encode(encoding='GBK')  # 编码
# print(byte.decode(encoding='UTF-8'))  # 如果编码解码用的字符集不同则会抛出UnicodeDecodeError异常

byte = str1.encode(encoding='GBK')  # 编码
print(byte.decode(encoding='GBK'))  # 解码 编码解码使用的字符集要一致

byte = str1.encode(encoding='UTF-8')
print(byte.decode(encoding='UTF-8'))
```

