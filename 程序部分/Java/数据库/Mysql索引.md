# Mysql索引

## 存储引擎：改变索引的存储位置及文件格式

聚簇索引：数据和文件放在一起：innodb

1. .frm：存放的是表结构
2. .ibd：存放数据文件和索引文件

注意：mysql的innodb存储引擎默认情况下会把所有数据文件放到表空间中，不会为每个单独的表保存一份数据文件

非聚簇索引数据和索引单独一个文件夹：MuISAM

1. .frm：存放表结构
2. .MYI：存放索引
3. .MYD：存放实际数据

索引文件的结构

1. hash
2. 二叉树
3. B树
4. B+树

## hash为什么不合适

存储方式：
在添加新缩影的时候需要计算指定列表的hash值，取模运算后计算出下标，将元素插入下表位置
**适合场景：等值查询**
**企业中多数查询是范围查询**，因此hash表不是很合适
hash表在使用的时候，**需要将全部的数据加载到内存**，比较耗费内存空间，也不合适



## 树

多叉树
二叉树
AVL平衡树

> AVL树是一颗严格意义上的平衡树，最高子树最低子树高度之差不能超过1，因此在进行元素插入的时候，会进行1到N次的旋转，严重影响插入的性能

红黑树

> 红黑树是基于AVL树的一个升级，损失了部分查阅的性能，来提升插入的性能，在红黑树中最低子树跟最高子树之差小于2即可，在插入的时候，不需要进行N多次的旋转操作，而且还加入了变色的特性，来满足插入和查询的性能查询的平衡

二叉树及其N多变种都不能支持索引，原因是树的深度无法控制或插入数据的性能比较低

多叉树

> 每个节点都有key，同时也包含data，而每个页存储空间是有限的，如果data比较大的话会导致每个节点存储的key数量变小
> 当存储的数量很大的时候会导致深度较大，增大查询时磁盘io次数，进而影响查询性能

mysql索引数据结构--B+Tree

> B+Tree是在BTree的基础之上做的一种优化，变化如下：
>
> 1. B+Tree每个节点可以包含更多的节点，这个做的原因有两个，第一个是因为降低树的高度第二个原因是将数据范围变为多个区间，区间越多，数据检索越快
> 2. 非叶子节点存储key、叶子节点存储key和数据
> 3. 叶子节点两两指针相互连接(符合磁盘预读特性)，顺序查询性能更高

---

## 回表

InnoDB是通过B+Tree结构对主键创建索引，然后叶子节点中存储记录，如果没有主键，那么会选择唯一键，如果没有唯一键，那么会生成一个6位的row_id（用户不可见）来作为主键
如果创建索引的键是其他字段，那么在叶子节点中存储的是该记录的主键，然后通过主键找到相应的记录，**这个过程叫回表**

---

## 索引的分类

1. 主键索引

   主键是一种唯一索引，但它必须指定为PRIMARY KEY，每个表只能有一个主键

   > 唯一且非空
   >
   > 自动递增：自增锁
   >
   > 推荐选择自动递增：在插入数据时创建新索引比较方便，直接往B+Tree后面加元素就可以
   >
   > 页分裂：如果需要插入的数据页满了，就需要单独申请一个新的数据页，然后移动部分数据过去，这个过程叫做页分裂，此时性能和空间使用率都会受到相应的影响
   >
   > 页合并

2. 唯一索引

   索引列的所有值都只能出现一次，即必须唯一，值可以为空

   > 唯一、可以为空
   >
   > 唯一索引不需要回表操作

3. 普通索引

   基本都索引类型，值可以为空，没有唯一性的限制(**覆盖索引**)

   > 可以不唯一、也可以为空
   >
   > 需要回表、一般回表都指的是Innodb
   >
   > **覆盖索引**：select的数据列只用从索引中就能够取得，不必从数据表中读取（对sql语句进行优化）

4. 全文索引

5. 组合索引

> 可以把多个列整合到一起创建索引
>
> 最左匹配原则：先匹配最左的字段
>
> 建立索引时要考虑磁盘占用率

---

## 索引下推

MySQL5.6添加的，用于优化数据查询

- 不使用索引条件下推优化时存储引擎通过索引检索到数据，然后返回给MySQL服务器，服务器然后判断数据是否符合条件。
- 当使用索引条件下推优化时，如果存在某些被索引的列的判断条件时，MySQL服务器将这一部分判断条件传递给存储引擎，然后由存储引擎通过判断索引是否符合MySQL服务器传递的条件，只有当索引符合条件时才会将数据检索出来返回给MySQL服务器。索引条件下推优化可以减少存储引擎查询基础表的次数，也可以减少MySQL服务器从存储引擎接收数据的次数。

---

